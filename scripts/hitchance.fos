#ifndef HITCHANCE_MODULE
#define HITCHANCE_MODULE

#include "_utils.fos"
#include "hitchance_h.fos"
#include "combat_h.fos"

int to_hit( CritterMutual& attacker, CritterMutual@ target, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo, uint16 hexX, uint16 hexY, bool randomHit )
{
	if( !valid( target ) && hexX == 0 && hexY == 0 )
	{
		return 0;
	}

	bool hexAttack = !valid( target ) && ( hexX != 0 && hexY != 0 );

	uint8 use = _WeaponModeUse( weaponMode );
	uint8 aim = _WeaponModeAim( weaponMode );
	if( attacker.Param[ CR_AUTO_AIM ] != HIT_LOCATION_NONE && aim == HIT_LOCATION_NONE )
	{
		aim = attacker.Param[ CR_AUTO_AIM ];
	}
	
	uint skillNum = _WeaponSkill ( weapon, use );
	int skillVal = attacker.Skill[ skillNum ];  
	int acMod = 0;
	int aimModifier = 0;
	int wpnMaxDist = _WeaponMaxDist( weapon, use );
	if( FLAG( weapon.Weapon_Perk, WEAPON_PERK_SCOPE_RANGE ) && attacker.Param[ CR_IS_WINDUPED ] > 0 )
	{
		wpnMaxDist *= 2;
	}
	
	int reach = 0;   
	int injureMod = attacker.IsDmgEye() ? BLIND_PENALTY_HTH : 0;
	int dist = 0;
	int optimal = 0;
	int faloff = 0;
	int weaponPerk = weapon.Weapon_Perk;
	
	if( valid( target ) )
	{
		dist = GetCrittersDistantion( attacker, target );
		acMod = target.Stat[ ST_ARMOR_CLASS ];
		
		if( target.TraitBase[TRAIT_BRUISER] != 0 )
		{
			acMod -= 25;
		}
		
		if( target.TraitBase[TRAIT_SMALL_FRAME] != 0 )
		{
			acMod += 25;
		}
		
		if( dist == 1 && ( IsHuman( target ) || IsMutant( target ) ) ) // Dodge from unarmed
		{
			if( !target.IsKnockout() )
			{
				uint8 a_dir = GetDirection( attacker.HexX, attacker.HexY, target.HexX, target.HexY );
				uint8 t_dir = target.Dir;
				uint8 dir_1 = 0, dir_2 = 0, dir_3 = 0;
				REVERSE_DIRECTION( dir_1, a_dir );
				GET_NEAR_DIRECTION( dir_1, dir_2, dir_3 );
				if( t_dir == dir_1 || t_dir == dir_2 || t_dir == dir_3 )
				{
					acMod += target.Skill[ SK_UNARMED ] / SKILL_MOD;
				}
			}
			
			acMod -= target.Param[ ST_DRUNK ];
		}
		
		if( skillNum == SK_UNARMED || skillNum == SK_MELEE_WEAPONS )
		{
			reach = ( wpnMaxDist - 1 ) * REACH_BONUS;
		}
	}
	else
	{
		dist = GetDistantion( attacker.HexX, attacker.HexY, hexX, hexY );
		acMod += 50;
	}

	if( valid( ammo ) )
	{
		acMod += ammo.Ammo_AcMod;
	}

	if( skillNum == SK_THROWING ) 
	{
		wpnMaxDist = MIN( wpnMaxDist, 3 * MIN( int(10), attacker.Stat[ ST_STRENGTH ] ) );
		if( attacker.Skill[SK_THROWING] >= 200 ) wpnMaxDist += 5;
	}
	
	int baseHitChance = skillVal;
	
	if( skillNum == SK_SMALL_GUNS || skillNum == SK_MEDIUM_GUNS || skillNum == SK_BIG_GUNS || skillNum == SK_THROWING )
	{
		optimal = HitchanceOptimal( wpnMaxDist, skillVal );
		
		if( FLAG( weaponPerk, WEAPON_PERK_LONG_RANGE ) )
		{
			wpnMaxDist += WEAPON_PERK_LONG_RANGE_BONUS;
		}
		
		faloff = HitchanceFaloff( wpnMaxDist, skillVal );
		
		baseHitChance = BaseHitChance( dist, optimal, faloff );

		//Log( "dist "+ dist + " optimal " +optimal+ " faloff " + faloff + " baseHitChance " + baseHitChance);

		if( dist <= optimal )
		{
			if(  skillVal > MAX_SKILL_DISTANCE )
			{
				baseHitChance += skillVal - MAX_SKILL_DISTANCE;
			}
		}
	}
	
	int toHitMod = 0;
	int handlingStrength = attacker.Stat[ ST_STRENGTH ];
	int reqStrength = weapon.Weapon_MinStrength;
	bool isUnarmed = weapon.Weapon_IsUnarmed;
	
	if( !isUnarmed && handlingStrength < reqStrength )
	{
		toHitMod -= ( reqStrength - handlingStrength ) * STRENGTH_MALLUS;
	}
	
	if( FLAG( weaponPerk, WEAPON_PERK_ACCURATE ) && dist <= ( optimal + faloff ) )
	{
		toHitMod += WEAPON_PERK_ACCURATE_BONUS;
	}
	
	if( _WeaponAnim2( weapon, use ) == ANIM2_BURST || attacker.Param[ CR_FULL_AUTO ] > 0 )
	{
		int rounds_fired = CLAMP( attacker.Param[ CR_AUTO_ROUNDS_FIRED ] - 1, 0, 500 );
		toHitMod -= rounds_fired * weapon.Weapon_Recoil;
	}
	
	if( !randomHit )
	{
		aimModifier = aimMod( aim );
	}

 	//Log( "baseHitChance " + baseHitChance + " acMod "  + acMod + " aimModifier " + aimModifier + " toHitMod " + toHitMod +  " reach " + reach + " injureMod " + injureMod );
		
	int hitChance = baseHitChance - acMod - aimModifier + toHitMod + reach - injureMod - attacker.Param[ ST_DRUNK ];

	Item@ hand = _CritGetItemHand( attacker );
	if( valid( hand ) )
	{
		bool brokenArm = attacker.Damage[ DAMAGE_LEFT_ARM ] + attacker.Damage[ DAMAGE_RIGHT_ARM ] > 0;
		
		if( brokenArm )
		{
			hitChance /= 2;
		}
		
		bool brokenTwoArms = attacker.Damage[ DAMAGE_LEFT_ARM ] * attacker.Damage[ DAMAGE_RIGHT_ARM ] > 0;

		if( FLAG( hand.Flags, ITEM_TWO_HANDS ) && brokenTwoArms )
		{
			return 0;
		}
	}
		
	int min_hit_chance = FLAG( weaponPerk, WEAPON_PERK_SUPPRESIVE ) ? 15 : MIN_HITCHANCE;
	
	return CLAMP( hitChance, min_hit_chance, MAX_HITCHANCE );
}

int aimMod( uint8 aim )
{
	int aimMod = __HitAimTorso;
	switch( aim )
	{
		case( HIT_LOCATION_EYES ):
			aimMod = __HitAimEyes;
			break;
		case( HIT_LOCATION_HEAD ):
			aimMod = __HitAimHead;
			break;
		case( HIT_LOCATION_GROIN ):
			aimMod = __HitAimGroin;
			break;
		case( HIT_LOCATION_LEFT_ARM ):
		case( HIT_LOCATION_RIGHT_ARM ):
			aimMod = __HitAimArms;
			break;
		case( HIT_LOCATION_LEFT_LEG ):
		case( HIT_LOCATION_RIGHT_LEG ):
			aimMod = __HitAimLegs;
			break;
	}
	
	return aimMod;
}

int HitchanceOptimal( int wpnMaxDist, int skillVal )
{
	if( skillVal >= MAX_SKILL_DISTANCE )
	{
		return wpnMaxDist;
	}
	
	int optimal = wpnMaxDist * skillVal / MAX_SKILL_DISTANCE;

	return optimal;
}

int HitchanceFaloff( int wpnMaxDist, int skillVal )
{
	int faloff = wpnMaxDist * skillVal / MAX_SKILL_DISTANCE;
	
	return faloff;
}

int BaseHitChance( int distance, int optimal, int faloff )
{
	if( distance <= optimal )
	{
		return MAX_HITCHANCE;
	}
	
	if( distance > ( optimal + faloff ) )
	{
		return MIN_HITCHANCE;
	} 

	int hitChance = int( MIN_HITCHANCE + ( cos( ( distance - optimal ) * 3.14f / faloff ) + 1 ) / 2 * ( MAX_HITCHANCE - MIN_HITCHANCE ) );
	
	return hitChance;
}


#endif // HITCHANCE_MODULE